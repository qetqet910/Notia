# 애플리케이션 초기화 및 렌더링 버그 해결 요약

## 1. 초기 증상

애플리케이션은 여러 가지 복합적인 문제를 겪고 있었습니다.

- 로그인 후 "사용자 정보 확인 중..." 또는 대시보드 화면에서 **무한 로딩** 발생.
- 특정 조건에서 **웹소켓 연결 오류** (`WebSocket is closed...`, `mismatch between bindings...`)가 콘솔에 반복적으로 출력됨.
- 대시보드 진입 시 **렌더링 오류** (`An error occurred in the <Dashboard> component`) 발생.
- 개발 환경에서 **CORS 정책 오류** 발생.

## 2. 문제의 근본 원인 및 해결 과정

여러 증상이 복합적으로 나타났지만, 핵심 원인은 크게 3가지였습니다.

### 원인 1: 앱 초기화 로직의 무한 루프 (가장 치명적인 문제)

- **문제점**: `authStore.ts`의 `persist` 미들웨어 설정 중, `onRehydrateStorage` 함수의 구조가 잘못되어 있었습니다. 이로 인해 앱이 렌더링될 때마다 `restoreSession` 함수가 반복적으로 호출되었고, `restoreSession`은 계속해서 로딩 상태를 `true`로 만들면서 무한 루프에 빠졌습니다.
- **해결책**: `onRehydrateStorage`의 함수 구조를 Zustand가 기대하는 올바른 형태로 수정하여, `restoreSession`이 앱 로드 시 **단 한 번만** 실행되도록 보장했습니다. 또한, `dashboard/index.tsx`에서 불필요하게 중복으로 세션을 체크하던 로직을 제거하여 초기화 과정을 단순화했습니다.

### 원인 2: 불안정한 데이터 구독(Realtime) 로직

- **문제점**: `dataStore.ts`의 실시간 구독 로직이 비효율적이고 여러 잠재적 오류를 포함하고 있었습니다.
    - `supabase.removeAllChannels()`의 무분별한 사용과 비동기 처리가 제대로 되지 않은 `unsubscribe` 로직이 **경쟁 상태(Race Condition)**를 유발하여 웹소켓 연결 오류를 일으켰습니다.
    - 모든 사용자가 동일한 채널 이름을 사용하여, 여러 사용자가 접속 시 서버에서 충돌이 발생했습니다.
- **해결책**: `dataStore.ts`의 전체 로직을 안정적인 새 버전으로 교체했습니다.
    - `unsubscribeAll`을 완전한 `async` 함수로 만들고 `Promise.all`을 사용해, 이전 연결이 **확실히 종료된 후** 새 연결을 시도하도록 보장했습니다.
    - `userId`를 포함한 고유 채널 이름을 사용하도록 변경했습니다.

### 원인 3: 데이터 무결성 문제로 인한 렌더링 오류

- **문제점**: `useNotes.ts` 훅과 `dashboard/index.tsx` 컴포넌트가 `dataStore`로부터 받은 데이터가 항상 완벽한 형태일 것이라고 가정했습니다. 하지만 데이터 배열 안에 `null` 값이 포함되어 있거나, 특정 속성(예: `tags`, `reminders`)이 `null`일 경우, `.filter`, `.map` 같은 배열 함수를 호출하다가 런타임 오류가 발생하여 앱이 중단되었습니다.
- **해결책**: `useNotes` 훅과 `Dashboard` 컴포넌트에서 데이터를 사용하는 모든 지점에 **방어적 코드**를 추가했습니다. `(notes || [])`, `(note.tags || [])`와 같이, 데이터가 `null`이거나 `undefined`일 가능성을 항상 염두에 두고 안전하게 빈 배열 등으로 처리하여 런타임 오류를 원천적으로 차단했습니다.
